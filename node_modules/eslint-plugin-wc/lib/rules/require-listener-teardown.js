"use strict";
/**
 * @fileoverview Requires that listeners be cleaned up on DOM disconnect
 * @author James Garbutt <https://github.com/43081j>
 */
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const rule = {
    meta: {
        docs: {
            description: 'Requires that listeners be cleaned up on DOM disconnect.',
            category: 'Best Practices',
            url: 'https://github.com/43081j/eslint-plugin-lit/blob/master/docs/rules/require-listener-teardown.md'
        },
        messages: {
            noTeardown: 'Event listeners attached in `connectedCallback` should be' +
                'torn down during `disconnectedCallback`'
        }
    },
    create(context) {
        // variables should be defined here
        const addListenerQuery = 'MethodDefinition[key.name="connectedCallback"] ' +
            'CallExpression[callee.property.name="addEventListener"]';
        const removeListenerQuery = 'MethodDefinition[key.name="disconnectedCallback"] ' +
            'CallExpression[callee.property.name="removeEventListener"]';
        const seen = new Map();
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        const onAddListener = (node) => {
            if (node.callee.type === 'MemberExpression' &&
                node.callee.object.type === 'ThisExpression') {
                const arg0 = node.arguments[0];
                if (arg0.type === 'Literal' && typeof arg0.value === 'string') {
                    seen.set(arg0.value, node);
                }
            }
        };
        const onRemoveListener = (node) => {
            if (node.callee.type === 'MemberExpression' &&
                node.callee.object.type === 'ThisExpression') {
                const arg0 = node.arguments[0];
                if (arg0.type === 'Literal' && typeof arg0.value === 'string') {
                    seen.delete(arg0.value);
                }
            }
        };
        const classExit = () => {
            for (const expr of seen.values()) {
                context.report({
                    node: expr,
                    messageId: 'noTeardown'
                });
            }
            seen.clear();
        };
        return {
            [addListenerQuery]: (node) => onAddListener(node),
            [removeListenerQuery]: (node) => onRemoveListener(node),
            'ClassExpression:exit': classExit,
            'ClassDeclaration:exit': classExit
        };
    }
};
module.exports = rule;
