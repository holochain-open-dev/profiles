"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
exports.__esModule = true;
exports.deriveKeys = exports.COMB = exports.sha256 = exports.Codec = exports.HoloError = exports.KeyManager = exports.Chaperone = void 0;
var client_js_1 = __importDefault(require("../build/client.js"));
var json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
var util_1 = require("./util");
exports.Codec = util_1.Codec;
exports.sha256 = util_1.sha256;
exports.KeyManager = util_1.KeyManager;
var data_translator_1 = __importDefault(require("@holo-host/data-translator"));
var conductor_api_1 = require("@holochain/conductor-api");
var util_2 = require("util");
var _b = require('../build/errors.js'), HoloError = _b.HoloError, RegistrationError = _b.RegistrationError, HostingError = _b.HostingError, UserError = _b.UserError;
exports.HoloError = HoloError;
var async_with_timeout = require('../build/async_with_timeout.js');
var TimeoutError = async_with_timeout.TimeoutError;
var msgpack = require('tiny-msgpack');
var DEFAULT_TIMEOUT = 5000;
var IS_BROWSER = typeof window === 'object' && window.constructor.name === 'Window';
var COMB = require('@holo-host/comb').COMB;
exports.COMB = COMB;
// if ( IS_BROWSER ) {
//     window.global			= (global as any);
// }
// These lines stop Typescript from complaining that these globals do not exist.  In the browser,
// they will exist, and in Node.js the importer must define these globals.  For example:
//
// ```js
// global.COMB = {
//     "connect": () => null,
//     "listen": () => null,
// }
// global.crypto = require('crypto');
// ```
//
// COMB is mocked because it can only work for real in a browser context.
// const COMB				= (global as any).COMB		|| (window as any).COMB;
var crypto = global.crypto || window.crypto;
// const fetch				= (global as any).fetch		|| (window as any).fetch;
var resolver_baseurl = process.env.RESOLVER_URL || 'https://devnet-resolver.holo.host';
var ENVOY_SIGNUP = 'holo/agent/signup';
var ENVOY_SIGNIN = 'holo/agent/signin';
var ENVOY_APP_INFO = 'holo/app_info';
var ENVOY_STATE_DUMP = 'holo/tmp/state_dump';
var ENVOY_CONFIRM = 'holo/service/confirm';
var ENVOY_WORMHOLE_REQ = 'holo/wormhole/event';
var ENVOY_WORMHOLE_REP = 'holo/wormhole/response';
var NODE_LOG_PREFIX = '\x1b[90mChaperone::console.log( \x1b[37m';
var NODE_LOG_SUFFIX = '\x1b[90m)\x1b[0m';
var RPC_ERROR_TYPES = {
    '-32700': 'Parse Error',
    '-32600': 'Invalid Request',
    '-32601': 'Method Not Found',
    '-32602': 'Invalid Params',
    '-32603': 'Internal Error'
};
function delay(t) {
    return new Promise(function (r) {
        setTimeout(r, t);
    });
}
var DEBUG_LEVEL = false;
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (DEBUG_LEVEL !== true)
        return;
    args = Chaperone.fmtargs.apply(Chaperone, args);
    console.log.apply(console, args);
}
function randomBytes(length) {
    if (length === void 0) { length = 32; }
    if (IS_BROWSER) {
        var array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto.randomBytes(length);
    }
}
function resolveHostsForHappAgent(hash, keys, new_agent) {
    return __awaiter(this, void 0, void 0, function () {
        var params, agent_id, base64_enc_agent_id, resp, data, agent_id_log, context, selected_host;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = {
                        happ_id: hash,
                        anonymous: false,
                        new_agent: new_agent,
                        date: new Date().toISOString()
                    };
                    agent_id = null;
                    if (!keys) {
                        log('Getting Hosts for anonymous user because given no agent keys');
                        params.anonymous = true;
                    }
                    else {
                        agent_id = util_1.Codec.AgentId.encode(keys.publicKey());
                        base64_enc_agent_id = util_1.Codec.Signature.encode(keys.publicKey());
                        params.agent_id = base64_enc_agent_id;
                        if (new_agent === true) {
                            log('User expects Resolver to have no record of this Agent (%s) encoded as (%s)', agent_id, base64_enc_agent_id);
                        }
                        else {
                            log('User expects Resolver to have an existing record of this Agent (%s) encoded as (%s)', agent_id, base64_enc_agent_id);
                        }
                    }
                    log('POST /resolve/hosts; HOST: %s; BODY: %s;', resolver_baseurl, params);
                    return [4 /*yield*/, fetch(resolver_baseurl + "/resolve/hosts", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(params)
                        })];
                case 1:
                    resp = _a.sent();
                    switch (resp.status) {
                        case 200:
                            break;
                        case 403:
                            throw new UserError('Attempted to sign up but had already signed up');
                        case 404:
                            throw new UserError("Attempted to sign in but couldn't find agent in resolver");
                        default:
                            throw new HoloError("Unhandled status response (" + resp.status + ") from resolver /resolve/hosts");
                    }
                    return [4 /*yield*/, resp.json()];
                case 2:
                    data = _a.sent();
                    agent_id_log = !agent_id && params.anonymous ? 'anonymous' : agent_id;
                    log('Resolved hosts for Agent (%s) -> [ %s ]', agent_id_log, data.hosts.map(String).join(', '));
                    if (data.hosts.length === 0) {
                        context = !keys ? 'anonymous Agent' : "Agent (" + agent_id + ")";
                        throw new HostingError("Cannot find a Host for App (" + hash + ") for " + context);
                    }
                    selected_host = arrayPickRandom(data.hosts);
                    log('Randomly selected Host: %s', selected_host);
                    return [2 /*return*/, selected_host];
            }
        });
    });
}
function resolveHostname2HappId(hostname) {
    return __awaiter(this, void 0, void 0, function () {
        var resp, data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (typeof hostname !== 'string')
                        throw new Error("Bad input: hostname paramater '" + hostname + "' (type " + typeof hostname + ") must be a string");
                    return [4 /*yield*/, fetch(resolver_baseurl + "/resolve/happId", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                url: hostname
                            })
                        })];
                case 1:
                    resp = _a.sent();
                    switch (resp.status) {
                        case 200:
                            break;
                        case 404:
                            throw new RegistrationError("App Hostname (" + hostname + ") is not registered.  Please contact Holo Support to learn about registering a hosted Holochain Application.");
                            break;
                        default:
                            throw new HoloError("Unhandled status response (" + resp.status + ") from resolver /resolve/happId");
                            break;
                    }
                    return [4 /*yield*/, resp.json()];
                case 2:
                    data = _a.sent();
                    log('Resolved Hostname (%s) -> HHA ID (%s)', hostname, data.happ_id);
                    return [2 /*return*/, data.happ_id];
            }
        });
    });
}
function assignHost2Agent(keys, host_id, getSignature) {
    return __awaiter(this, void 0, void 0, function () {
        var agent_id, date, message, resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!keys || !host_id)
                        throw new Error('Missing parameter');
                    agent_id = keys.publicKey();
                    date = new Date().toISOString();
                    message = {
                        agent_id: util_1.Codec.Signature.encode(agent_id),
                        host_id: host_id,
                        date: date
                    };
                    return [4 /*yield*/, fetch(resolver_baseurl + "/update/assignHost", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                Authorization: getSignature({ message: message })
                            },
                            body: JSON.stringify(message)
                        })];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, resp.status === 200 ? true : resp.status];
            }
        });
    });
}
function arrayPickRandom(list) {
    return list[Math.floor(Math.random() * list.length)];
}
/**
 * @module @holo-host/chaperone
 *
 * @description
 * ```html
 * <script type="text/javascript" src="./holo_hosting_chaperone.js"></script>
 * <script type="text/javascript">
 * (async () => {
 *     await chaperone.ready();
 *
 *     let response = await chaperone.callZomeFunction( "dna_alias", "zome_name", "func_name", {} );
 * })();
 * </script>
 * ```
 *
 */
var Chaperone = /** @class */ (function () {
    /**
     * Chaperone manages the connection(s), keys, and iframe message bus for a hApp user.
     *
     * @class Chaperone
     *
     * @param {number} port			- Set port property (default: 4656)
     * @prop {object} opts			- Options that were passed during construction
     *
     * @prop {object} COMB			- Local access to COMB library
     *
     * @prop {buffer} seed			- 32 bytes used for KeyPair seed
     * @prop {object} keys			- KeyManager instance
     * @prop {string} agent_id			- `uhCAk` encoding of public key
     * @prop {boolean} anonymous		- True when `this.seed` is random bytes
     *
     * @prop {string} hha_hash			- Holo Hosting App registered hApp Hash
     *
     * @prop {object} conn			- Current RPC WebSocket instance
     * @prop {string} host			- WebSocket server host
     * @prop {number} port			- WebSocket server port
     * @prop {boolean} opened			- True when WebSocket is in `readyState` === `OPEN`
     * @prop {boolean} wormhole_ready		- True when the wormhole listener has been established
     * @prop {object} wormhole_listeners	- Internal map of promises waiting for wormhole requests
     *
     * @example
     * const chaperone = new Chaperone();
     * await chaperone.ready();
     */
    function Chaperone(opts) {
        if (opts === void 0) { opts = Chaperone.DEFAULTS; }
        this.anonymous = true;
        this.agent_overrides = {};
        this.opened = false;
        this.wormhole_ready = false;
        this.wormhole_listeners = {};
        this.pending_confirms = {};
        // Apply default values to opts
        this.opts = Object.assign({}, Chaperone.DEFAULTS, opts);
        this.opts.connection = Object.assign({}, Chaperone.DEFAULTS.connection, opts.connection);
        DEBUG_LEVEL = this.opts.debug;
        log('Given configuration: %s', opts);
        log('Final configuration: %s', this.opts);
        this.port = this.opts.connection.port;
        this.mode = this.opts.mode;
        this.COMB = COMB;
        this.window = window;
        if (this.opts.comb === true) {
            this.comb_ready = this.setupCOMBListeners();
        }
        else {
            log("Skipping COMB setup because 'comb' option is set to '%s'", this.opts.comb);
        }
        this.initializing = this.init(this.opts.timeout);
    }
    Chaperone.fmtargs = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!IS_BROWSER) {
            if (typeof args[0] === 'string')
                args[0] = NODE_LOG_PREFIX + args[0];
            else
                args.unshift(NODE_LOG_PREFIX);
            args.push(NODE_LOG_SUFFIX);
        }
        return args.map(function (a) {
            if (typeof a !== 'string') {
                try {
                    if (a.constructor.name === 'Object' || Array.isArray(a))
                        return JSON.stringify(a, null, 4);
                    else
                        return a;
                }
                catch (err) { }
            }
            return a;
        });
    };
    Chaperone.prototype.alertParent = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.opts.comb === true)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.comb_ready];
                    case 1:
                        _b.sent();
                        log("Emitting '%s' to parent window over message bus with %s args", event, args.length);
                        (_a = this.parent_window.msg_bus).emit.apply(_a, __spreadArrays(['alert', event], args));
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    Chaperone.prototype.sendSignal = function (signalPayload) {
        return __awaiter(this, void 0, void 0, function () {
            var signal;
            return __generator(this, function (_a) {
                signal = signalPayload;
                if (this.mode === Chaperone.PRODUCT || this.mode === Chaperone.DEVELOP) {
                    signal = msgpack.decode(Buffer.from(signalPayload, 'base64'));
                }
                if (!signal.data)
                    throw new HoloError('Received unexpected signal: ', signal);
                this.signalStore = signal.data.payload; // store last signal for infrastructure test
                log("Chaperone received signal \"" + this.signalStore + "\" from envoy and is passing it via COMB");
                if (this.parent_window)
                    this.parent_window.sendSignal(signal);
                return [2 /*return*/];
            });
        });
    };
    Chaperone.prototype.processCredentials = function (credentials) {
        return __awaiter(this, void 0, void 0, function () {
            var w;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        w = window;
                        log('Processing credentials based on selected behavior: %s', w.expect);
                        if (!(w.expect === 'signin')) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.signIn(credentials.email, credentials.password)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        if (w.expect !== 'signup')
                            console.error(new Error("WARNING: Unknown 'expect' value (" + w.expect + ")"));
                        return [4 /*yield*/, this.signUp(credentials.email, credentials.password, credentials.joiningCode)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Chaperone.prototype.getCredentials = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.onCredentialsSubmitted(function (credentials) { return __awaiter(_this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, , 2, 3]);
                            _a = resolve;
                            return [4 /*yield*/, this.processCredentials(credentials)];
                        case 1:
                            _a.apply(void 0, [_b.sent()]);
                            return [3 /*break*/, 3];
                        case 2:
                            this.setFormIsProcessing(false);
                            return [7 /*endfinally*/];
                        case 3: return [2 /*return*/];
                    }
                });
            }); });
        });
    };
    Chaperone.prototype.getHhaHash = function () {
        return __awaiter(this, void 0, void 0, function () {
            var happ_host, _a, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.hha_hash) return [3 /*break*/, 4];
                        happ_host = this.happHost();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = this;
                        return [4 /*yield*/, resolveHostname2HappId(happ_host)];
                    case 2:
                        _a.hha_hash = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _b.sent();
                        this.showServiceTicketInfo(e_1);
                        if (e_1.message.includes('Unhandled status response')) {
                            this.showErrorMessage('Something went wrong. Please wait 30 seconds and try again.');
                        }
                        throw e_1;
                    case 4:
                        log('Using Happ ID (%s) from Resolver', this.hha_hash);
                        return [2 /*return*/];
                }
            });
        });
    };
    Chaperone.prototype.shouldAgentLogin = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(this.anonymous === false && !((_a = this.localStorage()) === null || _a === void 0 ? void 0 : _a.getItem('loggedIn')))) return [3 /*break*/, 3];
                        // if user is not anonymous (ie agent it thought to be logged in) and connection to envoy DOES NOT exit,
                        // ** then log out - connection needs to be reestablished and user identity confirmed...
                        log('Logging out holo client because connection to holo-envoy was lost...');
                        return [4 /*yield*/, this.getHhaHash()];
                    case 1:
                        _c.sent();
                        return [4 /*yield*/, this.signOut()];
                    case 2:
                        _c.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        if (this.anonymous === false && ((_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.getItem('loggedIn'))) {
                            // if user is not anonymous and connection to envoy exits, then return - no need to sign up
                            log('Aborting request because we already have a derived Agent (anonymous === %s)', this.anonymous);
                            return [2 /*return*/, false];
                        }
                        _c.label = 4;
                    case 4: return [2 /*return*/, true];
                }
            });
        });
    };
    Chaperone.prototype.processCOMBRequest = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var self, w, _a, shouldAgentSignUp, shouldAgentSignin, dna_alias, zome_name, function_name, fn_args, err_1, err_2, dnaAlias, err_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        self = this;
                        w = window;
                        log('Processing COMB request: %s with %s args', method, args.length);
                        _a = method;
                        switch (_a) {
                            case 'signUp': return [3 /*break*/, 1];
                            case 'signIn': return [3 /*break*/, 4];
                            case 'signOut': return [3 /*break*/, 7];
                            case 'zomeCall': return [3 /*break*/, 9];
                            case 'appInfo': return [3 /*break*/, 14];
                            case 'stateDump': return [3 /*break*/, 18];
                            case 'holoInfo': return [3 /*break*/, 21];
                        }
                        return [3 /*break*/, 22];
                    case 1:
                        // we would like the display to show first - in the future we should prob add a readonly/diable feature until connection is complete
                        w.showSignUp();
                        return [4 /*yield*/, this.shouldAgentLogin()];
                    case 2:
                        shouldAgentSignUp = _b.sent();
                        if (shouldAgentSignUp === false)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, this.getCredentials()];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        // we would like the display to show first - in the future we should prob add a readonly/diable feature until connection is complete
                        w.showSignIn();
                        return [4 /*yield*/, this.shouldAgentLogin()];
                    case 5:
                        shouldAgentSignin = _b.sent();
                        if (shouldAgentSignin === false)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, this.getCredentials()];
                    case 6: return [2 /*return*/, _b.sent()];
                    case 7:
                        log('Sign-out was called');
                        if (this.anonymous === true) {
                            log('Aborting request because we are already in an anonymous state (anonymous === %s)', this.anonymous);
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.signOut()];
                    case 8: return [2 /*return*/, _b.sent()];
                    case 9:
                        dna_alias = args[0], zome_name = args[1], function_name = args[2], fn_args = args[3];
                        _b.label = 10;
                    case 10:
                        _b.trys.push([10, 12, , 13]);
                        return [4 /*yield*/, this.callZomeFunction(dna_alias, zome_name, function_name, fn_args)];
                    case 11: return [2 /*return*/, _b.sent()];
                    case 12:
                        err_1 = _b.sent();
                        return [2 /*return*/, {
                                type: 'error',
                                payload: {
                                    error: err_1.name,
                                    message: err_1.message
                                }
                            }];
                    case 13: return [3 /*break*/, 23];
                    case 14:
                        _b.trys.push([14, 16, , 17]);
                        return [4 /*yield*/, this.getAppInfo()];
                    case 15: return [2 /*return*/, _b.sent()];
                    case 16:
                        err_2 = _b.sent();
                        return [2 /*return*/, {
                                type: 'error',
                                payload: {
                                    error: err_2.name,
                                    message: err_2.message
                                }
                            }];
                    case 17: return [3 /*break*/, 23];
                    case 18:
                        _b.trys.push([18, 20, , 21]);
                        dnaAlias = args[0];
                        return [4 /*yield*/, this.getHolochainStateDump(dnaAlias)];
                    case 19: return [2 /*return*/, _b.sent()];
                    case 20:
                        err_3 = _b.sent();
                        return [2 /*return*/, {
                                type: 'error',
                                payload: {
                                    error: err_3.name,
                                    message: err_3.message
                                }
                            }];
                    case 21: return [2 /*return*/, {
                            url: this.host
                        }];
                    case 22: return [3 /*break*/, 23];
                    case 23: return [2 /*return*/];
                }
            });
        });
    };
    Chaperone.prototype.setupCOMBListeners = function () {
        return __awaiter(this, void 0, void 0, function () {
            var listeners, events, _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.COMB ||
                            typeof this.COMB.connect !== 'function' ||
                            typeof this.COMB.listen !== 'function') {
                            log('Unexpected COMB library: %s (type %s)', String(this.COMB), typeof this.COMB);
                            throw new Error('COMB is not the library we expected');
                        }
                        listeners = {};
                        events = [
                            'signUp',
                            'signIn',
                            'signOut',
                            'zomeCall',
                            'appInfo',
                            'holoInfo'
                        ];
                        log("Setting up COMB listeners: '%s'", events.join("', '"));
                        events.map(function (method) {
                            listeners[method] = function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                log('Received COMB request: %s', method);
                                                return [4 /*yield*/, this.processCOMBRequest.apply(this, __spreadArrays([method], args))];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    });
                                });
                            };
                        });
                        _a = this;
                        return [4 /*yield*/, this.COMB.listen(listeners)];
                    case 1:
                        _a.parent_window = _b.sent();
                        log('COMB: parent <-> child handshake is complete, message bus is ready for traffic');
                        return [2 /*return*/];
                }
            });
        });
    };
    Chaperone.prototype.onCredentialsSubmitted = function (handleCredentials) {
        var w = window;
        var $ = w.$;
        var signin = {
            $email: $('#email'),
            $password: $('#password')
        };
        var signup = {
            $email: $('#signup-email'),
            $password: $('#signup-password'),
            $confirm: $('#signup-password-confirm'),
            $confirmFeedback: $('#signup-password-confirm-feedback'),
            $joiningCode: $('#signup-joining-code')
        };
        w.formSubmit = function (formElement) {
            if (w.formIsProcessing)
                return;
            w.setFormIsProcessing(true);
            formElement.classList.add('has-submitted');
            if (!w.validate(formElement)) {
                return;
            }
            var credentials = {
                email: null,
                password: null,
                joiningCode: null
            };
            if (formElement.matches('#sign-in form')) {
                credentials.email = signin.$email.val();
                credentials.password = signin.$password.val();
            }
            else if (formElement.matches('#sign-up form')) {
                credentials.email = signup.$email.val();
                credentials.password = signup.$password.val();
                credentials.joiningCode = signup.$joiningCode.val();
            }
            credentials.email = credentials.email.toLowerCase();
            handleCredentials(credentials);
            w.clearServiceTicketBanner();
            w.resetForms();
        };
    };
    Chaperone.prototype.showErrorMessage = function (message) {
        ;
        window.showErrorMessage(message);
    };
    Chaperone.prototype.showServiceTicketInfo = function (error) {
        var browser_version;
        if (process.env.NODE_ENV !== 'development' &&
            process.env.NODE_ENV !== 'production') {
            log('In testing mode, bypassing browser info.');
            browser_version = 'N/A';
        }
        else {
            var userAgent = window.navigator.userAgent;
            browser_version = util_1.browserInfo(userAgent);
        }
        var agent_id = this.agent_id || 'N/A';
        var host_id = this.host || this.happHost() || 'N/A';
        var happ_id = this.hha_hash || 'N/A';
        var chaperone_url = document.location.origin || 'N/A';
        var parsedError = util_2.inspect(error);
        window.showServiceTicketBanner(agent_id, host_id, happ_id, browser_version, chaperone_url, parsedError);
    };
    Chaperone.prototype.setFormIsProcessing = function (val) {
        if (window.setFormIsProcessing) {
            ;
            window.setFormIsProcessing(val);
        }
    };
    /**
     * Create an anonymous key pair.  Select a host and make a WebSocket connection.  Once the
     * WebSocket is in `readyState = OPEN`, register and subscribe for wormhole requests which are
     * automatically signed and returned to host.  By the time `init` is returns, the connection and
     * wormhole are ready for use.
     *
     * @async
     * @private
     *
     * @param {number} timeout		- Timeout for WebSocket connection
     *
     * @return {void} Return when setup is complete
     *
     * @example
     * await this.init( 5000 );
     * chaperone.opened         === true
     * chaperone.wormhole_ready === true
     * chaperone.anonymous      === true
     */
    Chaperone.prototype.init = function (timeout) {
        var _a;
        if (timeout === void 0) { timeout = DEFAULT_TIMEOUT; }
        return __awaiter(this, void 0, void 0, function () {
            var seedValid;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        log('Initializing mode is set to: %s (%s)', this.mode, mode_map[this.mode]);
                        if (this.mode === Chaperone.HCC) {
                            if (this.opts.web_user_legend !== undefined) {
                                this.agent_overrides = this.opts.web_user_legend;
                            }
                            else if (this.opts.agent_id === undefined) {
                                log('WARNING: this Chaperone has no configured users');
                            }
                        }
                        if (this.opts.agent_id) {
                            this.agent_id = this.opts.agent_id;
                            log("Using Agent ID (%s) assigned by Configuration '.agent_id'", this.opts.agent_id);
                        }
                        else {
                            seedValid = this.createAgentFromSeed();
                            if (!seedValid) {
                                this.createAnonymousAgent();
                            }
                        }
                        if (!(this.mode === Chaperone.DEVELOP || this.mode === Chaperone.HCC)) return [3 /*break*/, 1];
                        this.hha_hash = this.opts.app_id;
                        log('Skipping Resolver Hostname lookup and using configured instance prefix as HHA ID: %s', this.hha_hash);
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getHhaHash()];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        if (this.mode === Chaperone.HCC &&
                            this.opts.connection.host === undefined) {
                            if (!window.location.hostname) {
                                throw new Error('Unable to determine hostname - "window.location.hostname" is undefined and no host has been provided in opts.');
                            }
                            this.opts.connection.host = window.location.hostname;
                        }
                        // no need to re-invoke connect if already signed-in - connect call will invoke signout (which then triggers the creation of anonymous instance)
                        if (this.anonymous === false && !((_a = this.localStorage()) === null || _a === void 0 ? void 0 : _a.getItem('loggedIn')))
                            return [2 /*return*/];
                        return [4 /*yield*/, this.connect(false, timeout)];
                    case 4:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a valid Host for a given hostname or hApp ID (and Agent ID if signed in), and then create
     * a WebSocket connection to that host.
     *
     * @async
     * @private
     *
     * @param {number} timeout		- Timeout for WebSocket connection
     *
     * @return {void} Return when connection is open
     *
     * @example
     * await this.connect( 5000 );
     * chaperone.opened === true
     */
    Chaperone.prototype.connect = function (new_agent, timeout, joiningCode) {
        var _a, _b, _c, _d, _e;
        if (new_agent === void 0) { new_agent = false; }
        if (timeout === void 0) { timeout = DEFAULT_TIMEOUT; }
        if (joiningCode === void 0) { joiningCode = null; }
        return __awaiter(this, void 0, void 0, function () {
            var _f, _g, e_2, host, url_path, protocol, ws_url, reconnect_interval, disconnectedTimer, conn, conn_id, heartbeat, pong, original_agent_id, hasSignedOut, hasShownError, event_id, remoteCallParams, sign_up_response, sign_up_pack, sign_up_result, saved, err_4;
            var _this = this;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        log('Begin creation of an RPC WebSocket connection for %s Agent (timeout %s)', new_agent ? 'new' : 'existing', timeout);
                        // If our agent ID, host ID, or anonymity have changed, then the old cell IDs are invalid
                        delete this.cell_dictionary;
                        if (this.opened === true)
                            throw new Error("Connection already open, must run '.disconnect()' before starting a new connection.");
                        this.setFormIsProcessing(true);
                        if (!(this.mode === Chaperone.HCC)) return [3 /*break*/, 2];
                        this.host = this.opts.connection.host;
                        log('connecting to conductor app interface on port (%s) ', this.port);
                        _f = this;
                        return [4 /*yield*/, conductor_api_1.AppWebsocket.connect("ws://" + ((_a = this.host) !== null && _a !== void 0 ? _a : 'localhost') + ":" + this.port, timeout, this.sendSignal.bind(this))];
                    case 1:
                        _f.appWebsocket = _h.sent();
                        log('Skipping wormhole setup because we are in development mode (HCC)');
                        this.wormhole_ready = true;
                        this.setFormIsProcessing(false);
                        if (!this.anonymous) {
                            if (new_agent) {
                                this.alertParent('signup');
                            }
                            else {
                                this.alertParent('signin');
                            }
                        }
                        this.alertConnected();
                        return [2 /*return*/];
                    case 2:
                        if (!this.opts.connection.host) return [3 /*break*/, 3];
                        if (this.mode === Chaperone.PRODUCT &&
                            this.opts.connection.host === 'localhost' &&
                            this.opts.host_agent_id === undefined) {
                            throw new Error("Cannot set 'host' to localhost without also specifying 'host_agent_id' (" + this.opts.host_agent_id + ")");
                        }
                        this.host = this.opts.connection.host;
                        log("Using Host (%s) assigned by Configuration '.connection.host'", this.host);
                        return [3 /*break*/, 7];
                    case 3:
                        log('Requesting Host to be assigned by Resolver for hha_hash (%s)', this.hha_hash);
                        _h.label = 4;
                    case 4:
                        _h.trys.push([4, 6, , 7]);
                        _g = this;
                        return [4 /*yield*/, resolveHostsForHappAgent(this.hha_hash, this.anonymous === true ? false : this.keys, new_agent)];
                    case 5:
                        _g.host = _h.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        e_2 = _h.sent();
                        this.showServiceTicketInfo(e_2);
                        if (e_2 instanceof HostingError &&
                            e_2.message.includes('Cannot find a Host for App')) {
                            this.showErrorMessage('Something went wrong. Please wait 30 seconds and try again.');
                        }
                        if (e_2 instanceof UserError &&
                            e_2.message.includes('Attempted to sign up but had already signed up')) {
                            this.showErrorMessage('Could not create account. If you already have an account please login.');
                        }
                        if (e_2 instanceof UserError &&
                            e_2.message.includes("Attempted to sign in but couldn't find agent in resolver")) {
                            this.showErrorMessage("Login failed, please check email and password or sign up if you haven't yet");
                        }
                        (_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.removeItem('seed');
                        if (!!((_c = this.localStorage()) === null || _c === void 0 ? void 0 : _c.getItem('loggedIn'))) {
                            this.localStorage().removeItem('loggedIn');
                        }
                        throw e_2;
                    case 7:
                        host = this.host;
                        url_path = this.opts.connection.path;
                        protocol = this.opts.connection.secure === true ? 'wss' : 'ws';
                        ws_url = protocol + "://" + host + ":" + this.port + url_path + "?anonymous=" + this.anonymous + "&agent_id=" + encodeURIComponent(this.agent_id) + "&hha_hash=" + encodeURIComponent(this.hha_hash);
                        log('Create client to Host (%s://%s:%s%s) with connections settings: anonymous=%s agent_id=%s hha_hash=%s', protocol, host, this.port, url_path, this.anonymous, this.agent_id, this.hha_hash);
                        reconnect_interval = 2500;
                        disconnectedTimer = null;
                        conn = new client_js_1["default"](ws_url, {
                            autoconnect: true,
                            reconnect: true,
                            reconnect_interval: reconnect_interval,
                            max_reconnects: 0
                        });
                        conn_id = conn.id;
                        this.conn = conn;
                        heartbeat = function (conn, delay) {
                            clearTimeout(conn.pingTimeout);
                            conn.pingTimeout = setTimeout(function () {
                                log('About to close websocket because socket connection has timed out');
                                conn.close();
                            }, delay);
                        };
                        pong = function () {
                            heartbeat(_this.conn, delay);
                        };
                        this.conn.on('ping', function () {
                            pong();
                        });
                        this.conn.on('close', function () {
                            var _a;
                            log('WEBSOCKET TO ENVOY IS CLOSING. Ready state:', (_a = _this.websocket()) === null || _a === void 0 ? void 0 : _a.readyState);
                            clearTimeout(disconnectedTimer);
                            log('Clearing connection keep alive timeout');
                            clearTimeout(_this.conn.pingTimeout);
                            disconnectedTimer = setTimeout(
                            // Track the specific connection that got disconnected to avoid irrelevant notifications
                            function () { return _this.alertDisconnected(conn_id); }, reconnect_interval * 2);
                        });
                        original_agent_id = this.agent_id;
                        hasSignedOut = false;
                        hasShownError = false;
                        this.conn.on('error', function (err) {
                            var _a;
                            _this.showServiceTicketInfo('Websocket to envoy has error');
                            if (_this.agent_id !== original_agent_id)
                                return;
                            log('WEBSOCKET TO ENVOY HAS ERROR. (%s) Ready state:', util_2.inspect(err), (_a = _this.websocket()) === null || _a === void 0 ? void 0 : _a.readyState);
                            _this.alertDisconnected(conn_id);
                            if (_this.anonymous) {
                                if (!hasSignedOut) {
                                    hasSignedOut = true;
                                    _this.signOut();
                                }
                            }
                            else {
                                if (!hasShownError) {
                                    _this.showErrorMessage('Could not connect. Please try again later.');
                                    hasShownError = true;
                                }
                            }
                        });
                        return [4 /*yield*/, this.conn.opened(timeout)];
                    case 8:
                        _h.sent();
                        this.opened = true;
                        // When our websocket to envoy hiccups, we resubscribe and reactivate our app.
                        this.conn.on('open', function () { return __awaiter(_this, void 0, void 0, function () {
                            var event_id_1;
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        log('WEBSOCKET TO ENVOY IS OPENING. Ready state:', (_a = this.websocket()) === null || _a === void 0 ? void 0 : _a.readyState);
                                        clearTimeout(disconnectedTimer);
                                        // keep-alive heartbeat: return pong to server
                                        pong();
                                        return [4 /*yield*/, this.handleWormholeRequests()
                                            // only restablish sign_in connection and manage signals through envoy if agent was previously signed in/non-anonymous
                                        ];
                                    case 1:
                                        _b.sent();
                                        if (!(this.anonymous === false)) return [3 /*break*/, 3];
                                        event_id_1 = this.createEventId();
                                        log("Subscribing to event " + event_id_1);
                                        this.conn.subscribe(event_id_1);
                                        log('Attempting sign in following ws opening...');
                                        return [4 /*yield*/, this._signIn(host, new_agent)];
                                    case 2:
                                        _b.sent();
                                        _b.label = 3;
                                    case 3:
                                        this.alertConnected(conn_id);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        event_id = this.createEventId();
                        log("Subscribing to event " + event_id);
                        this.conn.subscribe(event_id);
                        this.conn.on(event_id, function (data) {
                            return _this.sendSignal(data);
                        });
                        if (!(this.anonymous === false)) return [3 /*break*/, 22];
                        _h.label = 9;
                    case 9:
                        _h.trys.push([9, 20, , 22]);
                        return [4 /*yield*/, this.handleWormholeRequests()];
                    case 10:
                        _h.sent();
                        remoteCallParams = [this.hha_hash, this.agent_id];
                        if (!new_agent) return [3 /*break*/, 17];
                        log("Calling '%s' because Agent wants to sign-up (new_agent == %s)", ENVOY_SIGNUP, new_agent);
                        if (joiningCode) {
                            log("Agent (%s) is calling '%s' with joiningCode (%s) as membrane_proof", new_agent, ENVOY_SIGNUP, joiningCode);
                            remoteCallParams.push(joiningCode);
                        }
                        return [4 /*yield*/, this.conn.call(ENVOY_SIGNUP, remoteCallParams)];
                    case 11:
                        sign_up_response = _h.sent();
                        sign_up_pack = data_translator_1["default"].parse(sign_up_response);
                        sign_up_result = sign_up_pack.value();
                        if (!(sign_up_result.message &&
                            sign_up_result.message.includes('AppAlreadyInstalled'))) return [3 /*break*/, 13];
                        log('App cell already exists for this user, switching to sign in: %s', sign_up_response);
                        return [4 /*yield*/, this._signIn(host, false)];
                    case 12:
                        _h.sent();
                        return [3 /*break*/, 14];
                    case 13:
                        if (sign_up_result !== true) {
                            log('Sign-up returned a non-success response: %s', sign_up_response);
                            this.showServiceTicketInfo('Error during User Sign-up.');
                            (_d = this.localStorage()) === null || _d === void 0 ? void 0 : _d.removeItem('seed');
                            if (!!((_e = this.localStorage()) === null || _e === void 0 ? void 0 : _e.getItem('loggedIn'))) {
                                this.localStorage().removeItem('loggedIn');
                            }
                            if (sign_up_pack.type === 'error') {
                                log('sign_up_result.name (%s)', sign_up_result.name);
                                log('sign_up_result.message (%s)', sign_up_result.message.toString());
                                if (sign_up_result.message.toLowerCase() === 'invalid joining code') {
                                    this.showErrorMessage('Invalid joining code. Please check and try again.');
                                }
                                else if (sign_up_result.message.toLowerCase() ===
                                    'missing membrane proof') {
                                    this.showErrorMessage('Please provide a joining code.');
                                }
                                else {
                                    this.showErrorMessage('Signup failed, please try again later. If the problem persists contact support.');
                                }
                                log('throwing error back to web client: UserError - %s', sign_up_result.message);
                                throw new UserError(sign_up_result.message);
                            }
                            else {
                                this.showErrorMessage('Signup failed, please try again later. If the problem persists contact support.');
                                throw new HoloError('Failed to sign-up');
                            }
                        }
                        _h.label = 14;
                    case 14:
                        if (!(this.mode === Chaperone.PRODUCT)) return [3 /*break*/, 16];
                        log('Alerting Resolver (via /assignHost) to new Host (%s) for Agent ID (%s)', host, this.agent_id);
                        return [4 /*yield*/, assignHost2Agent(this.keys, host, this.getSignature.bind(this))];
                    case 15:
                        saved = _h.sent();
                        if (saved !== true) {
                            log('Resolver returned a non-success response: %s', saved);
                            throw new HoloError('Failed to save assignedHost');
                        }
                        log('Resolver successfully assigned Host (%s) to Agent (%s)', host, this.agent_id);
                        _h.label = 16;
                    case 16:
                        this.alertParent('signup');
                        return [3 /*break*/, 19];
                    case 17: return [4 /*yield*/, this._signIn(host, new_agent)];
                    case 18:
                        _h.sent();
                        _h.label = 19;
                    case 19: return [3 /*break*/, 22];
                    case 20:
                        err_4 = _h.sent();
                        log('Sign-in/up failed with: %s', String(err_4));
                        // fallback to anonymous state
                        return [4 /*yield*/, this.signOut()];
                    case 21:
                        // fallback to anonymous state
                        _h.sent();
                        throw err_4;
                    case 22:
                        this.alertConnected();
                        log('Connection sequence is complete');
                        // Hide spinner when finished connecting anonymous agent
                        this.setFormIsProcessing(false);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Close current connection.
     *
     * @async
     * @private
     *
     * @return {void} Return when connection is closed
     *
     * @example
     * await this.disconnect();
     * chaperone.opened === false
     */
    Chaperone.prototype.disconnect = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Disconnecting from Host (%s)', this.host);
                        if (!this.conn) return [3 /*break*/, 4];
                        this.conn.reconnect = false;
                        this.conn.max_reconnects = 1;
                        this.conn.close();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.conn.closed(15000)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_3 = _a.sent();
                        if (e_3 instanceof TimeoutError) {
                            log('Timed out waiting for socket to close');
                        }
                        else {
                            throw e_3;
                        }
                        return [3 /*break*/, 4];
                    case 4:
                        log('Setting state to closed and not ready');
                        this.opened = false;
                        this.wormhole_ready = false;
                        this.alertParent('disconnected');
                        return [2 /*return*/];
                }
            });
        });
    };
    Chaperone.prototype.alertDisconnected = function (conn_id) {
        // If conn_id is specified, check that the current conenection is the one that got disconnected.
        if (conn_id == null || this.conn.id === conn_id) {
            this.alertParent('disconnected');
        }
    };
    Chaperone.prototype.alertConnected = function (conn_id) {
        if (conn_id == null || this.conn.id === conn_id) {
            this.alertParent('connected');
        }
    };
    /**
     * Async method that returns when the WebSocket and wormhole signing is setup.
     *
     * @async
     *
     * @param {number} timeout		- *Unused timeout*
     *
     * @return {this} Return self
     *
     * @example
     * try {
     *     await chaperone.ready( 5000 );
     * } catch ( err ) {
     *     // Timeout
     * }
     */
    Chaperone.prototype.ready = function (timeout) {
        if (timeout === void 0) { timeout = DEFAULT_TIMEOUT; }
        return __awaiter(this, void 0, void 0, function () {
            var id;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Started waiting for Chaperone ready state (timeout %s)', timeout);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, async_with_timeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                return __generator(this, function (_a) {
                                    return [2 /*return*/, new Promise(function (f, r) {
                                            _this.initializing["catch"](r);
                                            var curr_state = 1; // connection is not created yet
                                            id = setInterval(function () { return __awaiter(_this, void 0, void 0, function () {
                                                var last_state;
                                                var _a;
                                                return __generator(this, function (_b) {
                                                    last_state = curr_state;
                                                    if (this.conn)
                                                        // connection in progress
                                                        curr_state = 2;
                                                    if (this.opened === true)
                                                        // setting up wormhole
                                                        curr_state = 3;
                                                    if (this.opened === true &&
                                                        (this.anonymous === true || this.wormhole_ready === true))
                                                        // ready
                                                        curr_state = 4;
                                                    if (((_a = this.appWebsocket) === null || _a === void 0 ? void 0 : _a.client.socket.readyState) === 1) {
                                                        f(this);
                                                    }
                                                    if (curr_state === last_state) {
                                                        if (last_state === 4)
                                                            clearInterval(id);
                                                        return [2 /*return*/];
                                                    }
                                                    switch (curr_state) {
                                                        case 1:
                                                            log("Ready state %s - Chaperone's client has not been created yet", curr_state);
                                                            break;
                                                        case 2:
                                                            log('Ready state %s - Client connection is incomplete (%s)', curr_state, this.conn.readyState);
                                                            break;
                                                        case 3:
                                                            log('Ready state %s - Wormhole is not ready', curr_state);
                                                            break;
                                                        case 4:
                                                            log('Ready state %s - Connection to Host (%s) is ready for App traffic', curr_state, this.host);
                                                            f(this);
                                                            break;
                                                    }
                                                    return [2 /*return*/];
                                                });
                                            }); }, 100);
                                        })];
                                });
                            }); }, timeout)];
                    case 2: 
                    // States:
                    //   0 = none
                    //   1 = connection setup
                    //   2 = connecting
                    //   3 = wormhole setup
                    //   4 = connected
                    return [2 /*return*/, _a.sent()];
                    case 3:
                        clearInterval(id);
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the signature of a specific wormhole request.  Returns after wormhole response.
     *
     * **NOTE:** The original use case for this method is unit testing.  It may not be useful
         outside of the testing context.
     *
     * @async
     *
     * @param {number} id		- Wormhole request ID
     *
     * @return {string} Signature of wormhole request
     *
     * @example
     * let [signature,data] = chaperone.wormholeRequest( 0 );
     * // Signature is equivalent to
     * signature === chaperone.getSignature( data );
     */
    Chaperone.prototype.wormholeRequest = function (id) {
        var _this = this;
        return new Promise(function (f, r) {
            _this.wormhole_listeners[id] = [f, r];
        });
    };
    /**
     * Set up wormhole handler for RPC WebSocket connection.  Once complete, `this.wormhole_ready`
     * will be set to `true`.
     *
     * @async
     * @private
     *
     * @return {void} Returns after subscription is confirmed by server
     */
    Chaperone.prototype.handleWormholeRequests = function () {
        return __awaiter(this, void 0, void 0, function () {
            var signing_request_event_id, err_5, onSigningRequest;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Begin wormhole setup for Agent %s', this.agent_id);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.conn.call(ENVOY_WORMHOLE_REQ, [
                                this.agent_id
                            ])];
                    case 2:
                        signing_request_event_id = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_5 = _a.sent();
                        if (err_5.message.includes('unknown to this host')) {
                            return [2 /*return*/, log('WARNING: this host does not know this Agent identity. Sign-up must be the next call.')];
                        }
                        else {
                            console.error('Error in creating wormhole event', err_5);
                            throw new HoloError("RPC Error: " + JSON.stringify(err_5));
                        }
                        return [3 /*break*/, 4];
                    case 4:
                        if (typeof signing_request_event_id !== 'string') {
                            log("Unexpected Envoy endpoint type '%s'.  Expected type 'string'", typeof signing_request_event_id);
                            if (signing_request_event_id.name === 'HoloError')
                                throw new HoloError(signing_request_event_id.message);
                            else
                                throw new HoloError("Unexpected response from Host: " + JSON.stringify(signing_request_event_id));
                        }
                        log('Unique Envoy endpoint for signing requests: %s', signing_request_event_id);
                        log('Subscribe RPC WebSocket to unique endpoint (%s)', signing_request_event_id);
                        return [4 /*yield*/, this.conn.subscribe(signing_request_event_id)];
                    case 5:
                        _a.sent();
                        onSigningRequest = function (id, data) { return __awaiter(_this, void 0, void 0, function () {
                            var signature, response, _a, f, r;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        log('WORMHOLE #%s: received message length %s', id, data.length);
                                        signature = this.getSignature(data);
                                        log('WORMHOLE #%s: sending signature %s', id, signature);
                                        return [4 /*yield*/, this.conn.call(ENVOY_WORMHOLE_REP, [id, signature])];
                                    case 1:
                                        response = _b.sent();
                                        if (response !== true) {
                                            // update to (response.type !== true) after use hhdt package for wormhole...
                                            // TODO: Update to return wormhole error to web client
                                            console.error('%s returned non-success response: %s', ENVOY_WORMHOLE_REP, response);
                                        }
                                        if (this.wormhole_listeners[id] !== undefined) {
                                            log('Calling listener for wormhole #%s with signature (type %s) and data (type %s)', id, typeof signature, typeof data);
                                            _a = this.wormhole_listeners[id], f = _a[0], r = _a[1];
                                            f([signature, data]);
                                        }
                                        delete this.wormhole_listeners[id];
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        if (!this.conn.listeners(signing_request_event_id).includes(onSigningRequest)) {
                            log('Attach listener for wormhole requests');
                            this.conn.on(signing_request_event_id, onSigningRequest);
                        }
                        log('Wormhole setup is complete and listening for Envoy events @ %s', signing_request_event_id);
                        this.wormhole_ready = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new KeyManager instance using random bytes.
     *
     * @private
     *
     * @return {void}
     *
     * @example
     * this.createAnonymousAgent();
     * chaperone.anonymous === true
     */
    Chaperone.prototype.createAnonymousAgent = function () {
        try {
            this.seed = randomBytes(32);
            this.keys = new util_1.KeyManager(this.seed);
            this.agent_id = util_1.Codec.AgentId.encode(this.keys.publicKey());
            log('Created anonymous Agent %s from random bytes', this.agent_id);
            this.anonymous = true;
        }
        catch (err) {
            log('Failed to create anonymous Agent: %s', String(err));
            console.error(err);
        }
    };
    Chaperone.prototype.createAgentFromSeed = function () {
        var _a;
        var seed_hash = (_a = this.localStorage()) === null || _a === void 0 ? void 0 : _a.getItem('seed');
        if (!seed_hash) {
            return false;
        }
        log('Found locally saved session (seed): %s', seed_hash);
        if (this.mode === Chaperone.HCC && seed_hash in this.agent_overrides) {
            this.agent_id = this.agent_overrides[seed_hash];
            this.anonymous = false;
            log('Using Agent overrides from configuration to set Agent ID (%s)', this.agent_id);
            return true;
        }
        try {
            var seed = util_1.Codec.Digest.decode(seed_hash);
            this.seed = seed;
            this.keys = new util_1.KeyManager(this.seed);
            this.agent_id = util_1.Codec.AgentId.encode(this.keys.publicKey());
            log('Created Agent %s from stored seed (%s)', this.agent_id, seed);
            this.anonymous = false;
            return true;
        }
        catch (err) {
            log('Failed to create Agent from seed: %s', String(err));
            console.error(err);
            return false;
        }
    };
    /**
     * Creates a new KeyManager instance using derived seed.
     *
     * @private
     *
     * @return {void}
     *
     * @example
     * this.deriveAgent( email, password );
     * chaperone.anonymous === false
     */
    Chaperone.prototype.deriveAgent = function (email, password) {
        var _a, _b;
        log('Derive Agent from email/password (%s/******)', email);
        if (email in this.agent_overrides) {
            this.agent_id = this.agent_overrides[email];
            this.anonymous = false;
            // note: agent should already exist in conductor
            log('Used Agent overrides for email (%s) to set Agent ID (%s)', email, this.agent_id);
            (_a = this.localStorage()) === null || _a === void 0 ? void 0 : _a.setItem('seed', email);
            return;
        }
        if (this.opts.agent_id) {
            log("Skipping derive Agent because Configuration set '.agent_id' to %s", this.opts.agent_id);
            this.anonymous = false;
            return;
        }
        try {
            log('Derive seed from HHA ID / email / password: %s / %s / ******', this.hha_hash, email);
            this.seed = Buffer.from(util_1.deriveSeedFrom(util_1.Codec.HoloHash.decode(this.hha_hash), email, password));
            // NB: this.seed has been updated to use base64 encoding
            (_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.setItem('seed', util_1.Codec.Digest.encode(this.seed));
            this.keys = new util_1.KeyManager(this.seed);
            this.agent_id = util_1.Codec.AgentId.encode(this.keys.publicKey());
            log('Derived Agent ID: %s', this.agent_id);
            this.anonymous = false;
        }
        catch (err) {
            log('Failed to create derived Agent: %s', String(err));
            console.error(err);
        }
    };
    Chaperone.prototype.getAppInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            var installed_app_id, pkg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.ready()];
                    case 1:
                        _a.sent();
                        installed_app_id = this.anonymous
                            ? this.hha_hash
                            : this.hha_hash + ":" + this.agent_id;
                        if (!(this.mode === Chaperone.HCC)) return [3 /*break*/, 2];
                        // hhdt does not wrap the response in a payload obj when returning the data directly from the conductor
                        return [2 /*return*/, this.appWebsocket.appInfo({ installed_app_id: this.hha_hash }, DEFAULT_TIMEOUT)];
                    case 2: return [4 /*yield*/, this.conn.call(ENVOY_APP_INFO, { installed_app_id: installed_app_id })];
                    case 3:
                        pkg = _a.sent();
                        if (pkg.type === 'success') {
                            return [2 /*return*/, pkg.payload];
                        }
                        else {
                            console.error("Error while calling envoy app_info: " + data_translator_1["default"].parse(pkg));
                            throw new Error("Error while calling envoy app_info: " + data_translator_1["default"].parse(pkg));
                        }
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Chaperone.prototype.populateCellData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var appInfo, cells, cellMap, cellDictionary;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getAppInfo()];
                    case 1:
                        appInfo = _a.sent();
                        cells = appInfo.cell_data;
                        cellMap = cells.map(function (_a) {
                            var _b;
                            var cell_id = _a.cell_id, cell_nick = _a.cell_nick;
                            return (_b = {},
                                _b[cell_nick] = cell_id,
                                _b);
                        });
                        cellDictionary = cellMap.reduce(function (accumulator, current, _a) { return (__assign(__assign({}, accumulator), current[0])); });
                        this.cell_dictionary = cellDictionary;
                        return [2 /*return*/, cellDictionary];
                }
            });
        });
    };
    Chaperone.prototype.getHolochainStateDump = function (dnaAlias) {
        return __awaiter(this, void 0, void 0, function () {
            var installed_app_id, pkg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.mode == Chaperone.HCC)) return [3 /*break*/, 1];
                        throw new Error('state dump is not implemented for HCC mode');
                    case 1:
                        installed_app_id = this.anonymous
                            ? this.hha_hash
                            : this.hha_hash + ":" + this.agent_id;
                        return [4 /*yield*/, this.conn.call(ENVOY_STATE_DUMP, {
                                installed_app_id: installed_app_id,
                                dna_alias: dnaAlias
                            })];
                    case 2:
                        pkg = _a.sent();
                        if (pkg.type === 'success') {
                            return [2 /*return*/, pkg.payload];
                        }
                        else {
                            throw new Error("Error while calling envoy state_dump: " + data_translator_1["default"].parse(pkg));
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create a derived Agent and re-initialize connection process for a new Agent.  Returns once
     * the new WebSocket connection is in `readyState = OPEN`.
     *
     * @async
     *
     * @param {string} email		- Agent's email address
     * @param {string} password		- Agent's password
     * @param {number} timeout		- Connection timeout (default 5000)
     *
     * @return {void} Returns when new connection is open
     *
     * @example
     * await chaperone.signUp( "someone@example.com" , "Passw0rd!" );
     * // chaperone is now connected to a host for signed in user
     * chaperone.anonymous === false
     */
    Chaperone.prototype.signUp = function (email, password, joiningCode, _a) {
        var _b;
        var _c = (_a === void 0 ? {} : _a).timeout, timeout = _c === void 0 ? DEFAULT_TIMEOUT : _c;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        log('Sign-up with %s/****** (timeout %s)', email, timeout);
                        this.deriveAgent(email, password);
                        return [4 /*yield*/, this.disconnect()];
                    case 1:
                        _d.sent();
                        return [4 /*yield*/, this.connect(true, timeout, joiningCode)];
                    case 2:
                        _d.sent();
                        (_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.setItem('loggedIn', true);
                        return [2 /*return*/, this.anonymous === false];
                }
            });
        });
    };
    /**
     * Create a derived Agent and re-initialize connection process.  Returns once the new WebSocket
     * connection is in `readyState = OPEN`.
     *
     * @async
     *
     * @param {string} email		- Agent's email address
     * @param {string} password		- Agent's password
     * @param {number} timeout		- Connection timeout (default 5000)
     *
     * @return {void} Returns when new connection is open
     *
     * @example
     * await chaperone.signIn( "someone@example.com" , "Passw0rd!" );
     * // chaperone is now connected to a host for signed in user
     * chaperone.anonymous === false
     */
    Chaperone.prototype.signIn = function (email, password, _a) {
        var _b;
        var _c = (_a === void 0 ? {} : _a).timeout, timeout = _c === void 0 ? DEFAULT_TIMEOUT : _c;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        log('Sign-in with %s/****** (timeout %s)', email, timeout);
                        this.deriveAgent(email, password);
                        return [4 /*yield*/, this.disconnect()];
                    case 1:
                        _d.sent();
                        return [4 /*yield*/, this.connect(false, timeout)];
                    case 2:
                        _d.sent();
                        (_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.setItem('loggedIn', true);
                        return [2 /*return*/, this.anonymous === false];
                }
            });
        });
    };
    Chaperone.prototype._signIn = function (host, new_agent) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var sign_in_response, sign_in_pack, sign_in_result, err_6;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        log("Calling '%s' because Agent wants to sign in (new_agent == %s)", ENVOY_SIGNIN, new_agent);
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.conn.call(ENVOY_SIGNIN, [
                                this.hha_hash,
                                this.agent_id
                            ])];
                    case 2:
                        sign_in_response = _c.sent();
                        sign_in_pack = data_translator_1["default"].parse(sign_in_response);
                        sign_in_result = sign_in_pack.value();
                        if (sign_in_result === true) {
                            log('Sign-in returned a success response');
                            this.alertParent('signin');
                        }
                        else {
                            log('Sign in returned a non-success response: %s', sign_in_response);
                            (_a = this.localStorage()) === null || _a === void 0 ? void 0 : _a.removeItem('seed');
                            if (!!((_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.getItem('loggedIn'))) {
                                this.localStorage().removeItem('loggedIn');
                            }
                            if (sign_in_pack.type === 'error') {
                                throw new UserError(sign_in_result.message);
                            }
                            throw new HoloError('Failed to sign-in');
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        err_6 = _c.sent();
                        this.showServiceTicketInfo(err_6);
                        if (err_6.message.toLowerCase().includes('unknown to this host')) {
                            throw new HoloError("Wrong Host.  Host " + host + " cannot locate instance of " + this.hha_hash + " app for agent " + this.agent_id);
                        }
                        else {
                            ;
                            window.showErrorMessage("Login failed, please check email and password or sign up if you haven't yet");
                            throw new HoloError("Sign In Error: " + JSON.stringify(err_6));
                        }
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Remove signed in KeyManager instance and create a new anonymous state.
     *
     * @async
     *
     * @param {number} timeout		- Connection timeout (default 5000)
     *
     * @return {void} Returns when new connection is open
     *
     * @example
     * await chaperone.signOut();
     * // chaperone is now connected to a read-only host
     * chaperone.anonymous === true
     */
    Chaperone.prototype.signOut = function (_a) {
        var _b, _c;
        var _d = (_a === void 0 ? {} : _a).timeout, timeout = _d === void 0 ? DEFAULT_TIMEOUT : _d;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        log('Signing-out current Agent %s (timeout %s)', this.agent_id, timeout);
                        (_b = this.localStorage()) === null || _b === void 0 ? void 0 : _b.removeItem('seed');
                        if (!!((_c = this.localStorage()) === null || _c === void 0 ? void 0 : _c.getItem('loggedIn'))) {
                            this.localStorage().removeItem('loggedIn');
                        }
                        return [4 /*yield*/, this.disconnect()];
                    case 1:
                        _e.sent();
                        this.alertParent('signout');
                        this.createAnonymousAgent();
                        // Make anonymous connection in the background
                        this.connect(false, timeout);
                        log('Sign-Out sequence is complete');
                        return [2 /*return*/, this.anonymous === true];
                }
            });
        });
    };
    Chaperone.prototype.getCellId = function (dna_alias) {
        return __awaiter(this, void 0, void 0, function () {
            var cell_id;
            return __generator(this, function (_a) {
                if (!this.cell_dictionary) {
                    throw new Error('cell_data is undefined');
                }
                cell_id = this.cell_dictionary[dna_alias];
                if (!cell_id) {
                    throw new Error("No cell_id corresponding with " + dna_alias);
                }
                return [2 /*return*/, cell_id];
            });
        });
    };
    /**
     * Call a zome function on the connected Host with given parameters. `installed_app_id` is derived
     * by combining `this.hha_hash`, and `this.agent_id`. When signed
     * in, the Agent ID and payload signature will be added to every request.
     *
     * @async
     *
     * @param {string} dna_alias - Identifier for specific DNA of this hApp. Must match the DNA alias defined in HHA
     * @param {string} zome_name - Zome name
     * @param {string} function_name - Zome function name
     * @param {any} args - Function arguments
     *
     * @return {*} Response from Host
     *
     * @example
     * let data = await chaperone.callZomeFunction( "holofuel", "transactions", "list_pending" );
     */
    Chaperone.prototype.callZomeFunction = function (dna_alias, zome_name, function_name, args) {
        return __awaiter(this, void 0, void 0, function () {
            var cell_id, call_spec, payload, service_signature, request, response, err_7, message, pack, result, response_id, host_response, zomeCall_response, confirmation_response, decodedResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Initializing zome function call: %s : %s -> %s', dna_alias, zome_name, function_name);
                        return [4 /*yield*/, this.ready()];
                    case 1:
                        _a.sent();
                        if (!!this.cell_dictionary) return [3 /*break*/, 3];
                        // Note: Do not move this call to connect -
                        // ** populateCellData and all other app level calls must be
                        // **  called *after* sign-in/sign-up process is complete (ie: ReadyState 4 is in effect)
                        return [4 /*yield*/, this.populateCellData()];
                    case 2:
                        // Note: Do not move this call to connect -
                        // ** populateCellData and all other app level calls must be
                        // **  called *after* sign-in/sign-up process is complete (ie: ReadyState 4 is in effect)
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.getCellId(dna_alias)];
                    case 4:
                        cell_id = _a.sent();
                        log('Zome call args that chaperone gets', args);
                        call_spec = {
                            cell_id: cell_id,
                            dna_alias: dna_alias,
                            zome: zome_name,
                            "function": function_name,
                            args: this.mode === Chaperone.HCC
                                ? args
                                : Buffer.from(msgpack.encode(args)).toString('base64')
                        };
                        if (!(this.mode === Chaperone.HCC)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.localCallZome(call_spec)];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6:
                        // Call_Spec wrapper needs the Agent ID and a "signature" property.
                        //
                        // Signed-in values
                        //
                        //     anonymous   = false
                        //     agent_id    = Agent ID
                        //     signature   = sign( call_spec )
                        //
                        // NOT signed-in should be
                        //
                        //     anonymous   = true
                        //     agent_id    = Ephemeral Agent ID
                        //     signature   = sign( call_spec )
                        //
                        call_spec['hha_hash'] = this.hha_hash;
                        payload = {
                            timestamp: [Math.floor(new Date().getTime() / 1000), 0],
                            host_id: this.hostId(),
                            call_spec: call_spec
                        };
                        log('Added timestamp (%s) and Host ID (%s) to payload', payload.timestamp, payload.host_id);
                        return [4 /*yield*/, this.requestServiceSignature(payload)];
                    case 7:
                        service_signature = _a.sent();
                        request = {
                            anonymous: this.anonymous,
                            agent_id: this.agent_id,
                            payload: payload,
                            service_signature: service_signature
                        };
                        log('Attached payload signature (%s) from Agent (%s)', service_signature, this.agent_id);
                        _a.label = 8;
                    case 8:
                        _a.trys.push([8, 10, , 11]);
                        log('Sending request signature %s to Envoy', service_signature);
                        log('Zome call args that envoy will see', msgpack.decode(Buffer.from(request.payload.call_spec.args, 'base64')));
                        return [4 /*yield*/, this.conn.call('holo/call', request)];
                    case 9:
                        response = _a.sent();
                        return [3 /*break*/, 11];
                    case 10:
                        err_7 = _a.sent();
                        message = void 0;
                        // Unexpected Holo infrastructure error
                        console.error(err_7);
                        if (err_7 instanceof Error)
                            message = String(err_7);
                        else if (RPC_ERROR_TYPES[err_7.code] !== undefined)
                            message = RPC_ERROR_TYPES[err_7.code] + " (" + err_7.code + "): " + err_7.message;
                        else if (err_7.code <= -32000 && err_7.code > -32100)
                            message = err_7.message + " -> " + (err_7.data ? JSON.stringify(err_7.data) : '(no err.data available)');
                        else
                            message = "'holo/call' error: Error type unknown: " + err_7.constructor.name;
                        throw new HoloError(message);
                    case 11:
                        pack = data_translator_1["default"].parse(response);
                        result = pack.value();
                        response_id = pack.metadata('response_id');
                        host_response = pack.metadata('host_response');
                        // Holo error
                        if (pack.type === 'error') {
                            log('Received error response from Envoy: %s', pack);
                            log('Forwarding on error pack to client');
                            return [2 /*return*/, pack];
                        }
                        zomeCall_response = result.zomeCall_response;
                        log('Schedule service confirmation for response (%s) initiated by request (%s)', response_id, service_signature);
                        return [4 /*yield*/, this.sendServiceConfirmation(response_id, host_response)["catch"](function (err) {
                                if (err instanceof Error) {
                                    log('Received error response from Envoy: %s', err);
                                    throw err;
                                }
                                else {
                                    log('Service confirmation failed for request %s: %s', service_signature, String(err));
                                    console.error(err);
                                }
                            })];
                    case 12:
                        confirmation_response = _a.sent();
                        if (confirmation_response.type === 'error') {
                            log('Returning non-successful result for request to web client: %s', service_signature);
                            // fwd on hhdt package errors to web client
                            // Temporary Solution: We are mpt returning the response since we do not handle serviceloger failure in case of Header Moving or some other bug that is not the providers fault
                            // return confirmation_response;
                        }
                        decodedResponse = msgpack.decode(Buffer.from(zomeCall_response, 'base64'));
                        log('Returning successful result (type %s) for request %s', typeof result, service_signature);
                        return [2 /*return*/, decodedResponse];
                }
            });
        });
    };
    Chaperone.prototype.localCallZome = function (call_spec) {
        return __awaiter(this, void 0, void 0, function () {
            var localCallSpec, ret, err_8;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        log('Calling Conductor directly because we are in development mode (HCC)');
                        localCallSpec = {
                            cell_id: call_spec.cell_id,
                            zome_name: call_spec.zome,
                            fn_name: call_spec["function"],
                            provenance: util_1.Codec.AgentId.decodeToHoloHash(this.agent_id),
                            payload: call_spec.args
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.appWebsocket.callZome(localCallSpec, DEFAULT_TIMEOUT)];
                    case 2:
                        ret = _a.sent();
                        console.log('zome call returned', ret);
                        return [2 /*return*/, ret];
                    case 3:
                        err_8 = _a.sent();
                        console.log('zome call errored', err_8);
                        throw err_8;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sign and send confirmation of service for a received response.
     *
     * @async
     * @private
     *
     * @param {string} response_id	- Received response ID
     * @param {object} response		- Received response object
     *
     * @return {string} confirmation ID
     */
    Chaperone.prototype.sendServiceConfirmation = function (response_id, host_response) {
        return __awaiter(this, void 0, void 0, function () {
            var response_signature, response_digest, metrics, confirmation_payload, confirmation_signature, service_confirmation, confirm_response, confirm_pack, confirm_result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.pending_confirms[response_id] = true;
                        response_signature = this.signPayload(host_response.response_hash);
                        log('Added pending confirmation to list for response (%s) with response signature: %s', response_id, response_signature);
                        host_response['signed_response_hash'] = response_signature;
                        return [4 /*yield*/, this.requestDigest(host_response)];
                    case 1:
                        response_digest = _a.sent();
                        metrics = {
                            // TODO: Replace hardcoded values with actual:
                            response_received: [165303, 0]
                        };
                        confirmation_payload = {
                            response_digest: response_digest,
                            metrics: metrics
                        };
                        confirmation_signature = this.signPayload(confirmation_payload);
                        service_confirmation = {
                            confirmation: confirmation_payload,
                            confirmation_signature: confirmation_signature
                        };
                        log('Sending confirmation payload with response signature (%s) and confirmation signature (%s)', response_signature, confirmation_signature);
                        return [4 /*yield*/, this.conn.call(ENVOY_CONFIRM, [
                                response_id,
                                response_signature,
                                service_confirmation
                            ])
                            // TODO: Update with/provide example of rsm servicelogger validation error:
                            // {
                            //     error: {
                            //         name: 'HoloError',
                            //         message: 'servicelogger.log_service failed: Error: {\n' +
                            //             '    "kind": {\n' +
                            //             '        "ValidationFailed": "Signature ox/+58Ven6AED929BjvnMc39e70CZS00quX7wjGD4PKcSw3ZPibfwpqAsrbR/ALKJUIcOG+XU9YumwJaGiIpAA== invalid for service_log: {\\"client_metrics\\":{\\"duration\\":\\"1s\\"},\\"response_hash\\":\\"QmeRzSjTersKsqDdn8T5msF7iRkbv4BiX7zuBT15ErBkxC\\"}"\n' +
                            //             '    },\n' +
                            //             '    "file": "crates/core/src/nucleus/ribosome/runtime.rs",\n' +
                            //             '    "line": "220"\n' +
                            //             '}'
                            //     }
                            // }
                        ];
                    case 2:
                        confirm_response = _a.sent();
                        // TODO: Update with/provide example of rsm servicelogger validation error:
                        // {
                        //     error: {
                        //         name: 'HoloError',
                        //         message: 'servicelogger.log_service failed: Error: {\n' +
                        //             '    "kind": {\n' +
                        //             '        "ValidationFailed": "Signature ox/+58Ven6AED929BjvnMc39e70CZS00quX7wjGD4PKcSw3ZPibfwpqAsrbR/ALKJUIcOG+XU9YumwJaGiIpAA== invalid for service_log: {\\"client_metrics\\":{\\"duration\\":\\"1s\\"},\\"response_hash\\":\\"QmeRzSjTersKsqDdn8T5msF7iRkbv4BiX7zuBT15ErBkxC\\"}"\n' +
                        //             '    },\n' +
                        //             '    "file": "crates/core/src/nucleus/ribosome/runtime.rs",\n' +
                        //             '    "line": "220"\n' +
                        //             '}'
                        //     }
                        // }
                        delete this.pending_confirms[response_id];
                        confirm_pack = data_translator_1["default"].parse(confirm_response);
                        confirm_result = confirm_pack.value();
                        if (confirm_pack.type === 'error') {
                            // If hhdt error, fwd on to web client
                            log('%s returned non-success response', ENVOY_CONFIRM);
                            log('forwarding error response to web client: %s', confirm_pack);
                            return [2 /*return*/, confirm_pack];
                        }
                        else if (confirm_result !== true) {
                            if (confirm_response.error &&
                                confirm_response.error.name === 'HoloError') {
                                throw new HoloError(confirm_response.error.message);
                            }
                            else {
                                throw new Error(confirm_response.error);
                            }
                        }
                        log('Completed pending confirmation (%s)', response_id);
                        return [2 /*return*/, confirm_pack];
                }
            });
        });
    };
    /**
     * Shutdown any connections and change `this.opened` to `false`.
     *
     * @async
     *
     * @return {void} Returns after connections are closed
     *
     * @example
     * await chaperone.close();
     * chaperone.opened === false
     */
    Chaperone.prototype.close = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.disconnect()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get the `WebSocket` instance for our current connection.  RPC WebSocket is a class that wraps
     * the real WebSocket connection.  Unfortunately, the `rpc-websockets` module stores the socket
     * differently on web vs node.js implementations.
     *
     * @return {WebSocket} The real WebSocket instance
     *
     * @example
     * let ws = chaperone.websocket();
     * ws.constructor.name === "WebSocket";
     */
    Chaperone.prototype.websocket = function () {
        var _a, _b;
        if (!this.opened) {
            log('WARN: Returned WebSocket is not open and may be replaced by rpc-websocket library once open');
        }
        // 'rpc-websockets' is not consistent between their node and web implementations.  The
        // actually WebSocket object is burried in '.socket.socket' in a browser context.
        return IS_BROWSER ? (_a = this.conn) === null || _a === void 0 ? void 0 : _a.socket.socket : (_b = this.conn) === null || _b === void 0 ? void 0 : _b.socket;
    };
    /**
     * Get the Agent ID of the signed in user.  Returns "anonymous" if user is not signed in.
     *
     * @return {string} Agent ID
     *
     * @example
     * let agent_id = chaperone.agentId();
     */
    Chaperone.prototype.agentId = function () {
        if (typeof this.agent_id !== 'string')
            throw new Error("Agend ID should be a string starting with uhCAk.  Found '" + this.agent_id + "' (type " + typeof this.agent_id + ")");
        return this.anonymous === true ? 'anonymous' : this.agent_id;
    };
    /**
     * Get the Host ID of the selected Host.
     *
     * @return {string} Host ID
     *
     * @example
     * let host_id = chaperone.hostId();
     */
    Chaperone.prototype.hostId = function () {
        // In production, the host string will look like `<host_id>.holohost.net`
        if (this.opts.host_agent_id) {
            log("Returning Host ID (%s) assigned by Configuration '.host_agent_id'", this.opts.host_agent_id);
            return this.opts.host_agent_id;
        }
        var domains = this.host.split('.');
        var host_id = util_1.Codec.AgentId.encode(util_1.Codec.Base36.decode(domains[0]));
        log('Using Host ID (%s) found in URI subdomain (%s)', host_id, this.host);
        return host_id;
    };
    /**
     * Get the Host address of the parent window (hApp UI).
     *
     * @private
     *
     * @return {string} Domain
     *
     * @example
     * let happ_host = this.happHost();
     */
    Chaperone.prototype.happHost = function () {
        try {
            var url = window.location != window.parent.location
                ? document.referrer
                : document.location.href;
            log('Returing host from URL: %s', url);
            return new URL(url).host;
        }
        catch (err) {
            log('Failed to determine App host: %s', String(err));
            console.error(err);
        }
    };
    /**
     * Get the base64 encoded signature for a given data object.  Converts objects using
     * `JSON.stringify` when given data is not a `string`.
     *
     * @param {string|object} data	- Data to be signed (strings are assumed to be base64)
     *
     * @return {string} Signature
     *
     * @example
     * let signature = chaperone.getSignature( { "email": "someone@example.com" );
     */
    Chaperone.prototype.getSignature = function (data) {
        var msg_bytes;
        if (typeof data === 'string') {
            msg_bytes = util_1.Codec.Signature.decode(data);
            log('Decoded base64 message (length %s) into bytes (length %s)', data.length, msg_bytes.length);
        }
        // Check if data is Buffer that is passed as a JSON of type {type, data}
        else if (data.type === 'Buffer') {
            msg_bytes = Buffer.from(data.data);
        }
        else {
            msg_bytes = msgpack.encode(data);
        }
        var sig_bytes = this.keys.sign(msg_bytes);
        var signature = util_1.Codec.Signature.encode(sig_bytes);
        log('Signature (%s) for message bytes <%s...%s>', signature, msg_bytes.slice(0, 4).join(', '), msg_bytes.slice(-4).join(', '));
        return signature;
    };
    Chaperone.prototype.requestServiceSignature = function (payload) {
        return __awaiter(this, void 0, void 0, function () {
            var pack, args_hash, pkg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pack = JSON.parse(JSON.stringify(payload));
                        return [4 /*yield*/, this.requestDigest(pack.call_spec.args)];
                    case 1:
                        args_hash = _a.sent();
                        log("Added 'args' hash (%s) to call spec", args_hash);
                        pkg = {
                            call_spec: {
                                args_hash: args_hash,
                                "function": pack.call_spec["function"],
                                zome: pack.call_spec.zome,
                                dna_alias: pack.call_spec.dna_alias,
                                hha_hash: pack.call_spec.hha_hash
                            },
                            host_id: pack.host_id,
                            timestamp: pack.timestamp
                        };
                        log('Signing request pack: %s', pkg);
                        return [2 /*return*/, this.signPayload(pkg)];
                }
            });
        });
    };
    Chaperone.prototype.signPayload = function (data) {
        var msg_bytes;
        msg_bytes = msgpack.encode(data);
        log('Serialized message and converted to bytes (length %s); data[0..10]: %s', msg_bytes.length, String(data).slice(0, 10));
        var signature = this.keys.sign(msg_bytes);
        log('Signature (%s) for message bytes <%s...%s>', signature, msg_bytes.slice(0, 4).join(', '), msg_bytes.slice(-4).join(', '));
        return util_1.Codec.Signature.encode(signature);
    };
    Chaperone.prototype.requestDigest = function (payload) {
        return __awaiter(this, void 0, void 0, function () {
            var serialized_args, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        serialized_args = typeof payload === 'string' ? payload : json_stable_stringify_1["default"](payload);
                        _b = (_a = util_1.Codec.Digest).encode;
                        return [4 /*yield*/, util_1.sha256(Buffer.from(serialized_args, 'utf8'))];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    Chaperone.prototype.createEventId = function () {
        return "signal:" + this.agent_id + ":" + this.hha_hash;
    };
    Chaperone.prototype.localStorage = function () {
        // In Chrome's Incognito Mode, accessing localStorage throws an exception.
        try {
            return this.window.localStorage;
        }
        catch (e) {
            return null;
        }
    };
    Chaperone.PRODUCT = 0;
    Chaperone.DEVELOP = 1;
    Chaperone.HCC = 2;
    Chaperone.DEFAULTS = {
        mode: Chaperone.PRODUCT,
        timeout: DEFAULT_TIMEOUT,
        debug: false,
        comb: true,
        connection: {
            port: 4656,
            secure: false,
            path: '/hosting/'
        }
    };
    Chaperone.COMB = COMB;
    return Chaperone;
}());
exports.Chaperone = Chaperone;
var mode_map = (_a = {},
    _a[Chaperone.HCC] = 'HCC',
    _a[Chaperone.DEVELOP] = 'DEVELOP',
    _a[Chaperone.PRODUCT] = 'PRODUCT',
    _a);
function deriveKeys(hha_hash, email, password) {
    var seed = Buffer.from(util_1.deriveSeedFrom(util_1.Codec.HoloHash.decode(hha_hash), email, password));
    return new util_1.KeyManager(seed);
}
exports.deriveKeys = deriveKeys;
